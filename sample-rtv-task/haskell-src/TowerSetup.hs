{-# OPTIONS_GHC -fno-warn-orphans #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE QuasiQuotes #-}

module TowerSetup where

import Ivory.Tower
import Checker hiding (main)

import Ivory.Language
import qualified Ivory.Tower.Compile.FreeRTOS as F
import qualified Ivory.Compile.C.CmdlineFrontend as C

--------------------------------------------------------------------------------

[ivory|

struct assignment
  { var_id :: Stored (Ix 100)
  ; value  :: Stored Uint32
  }

|]

--------------------------------------------------------------------------------

-- -- XXX how do I allocate something on the stack before the stack loop?
-- Seems ok from foobar example
-- fromRx :: MemArea (Struct "assignment")
-- fromRx = area "fromRx" Nothing

--------------------------------------------------------------------------------

-- proxy for what the function will really do when implemented
-- foo :: Def ('[Ref s (Struct "assigment")] :-> ())
-- foo = importProc "foo" "foo.c"

-- foo :: Def ('[ConstRef s (Struct "assignment")] :-> Uint32)
-- foo = proc "foo" $ \a -> body $ ret =<< deref (a ~> value)

--------------------------------------------------------------------------------

-- What to do if a property fails (in this case, led_set(1, 1))?
action :: Def ('[] :-> ())
action = importProc "led_set" "FreeRTOS.h"

append_to_history :: Def ('[Ix 100, Uint32] :-> ())
append_to_history = importProc "append_to_history" "instrumented.h"

-- XXX Seems cool to redefine imported types...
append_to_history' :: Def ('[Ix 100, Uint16] :-> ())
append_to_history' = importProc "append_to_history" "instrumented.h"

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- Library functions

mkHistory :: Def ('[ConstRef s (Struct "assignment")] :-> ())
mkHistory = proc "mkHistory" $ \s -> body $ do
  var <- deref (s ~> var_id)
  val <- deref (s ~> value)
  call_ append_to_history var val

--------------------------------------------------------------------------------

-- "check_properties" is automatically generated by the RTV system and always
-- has the same type.  We just have to call it and see if it's true.
check_properties :: Def ('[] :-> IBool)
check_properties = importProc "check_properties" "runtime-checker.h"

runCheck :: Def ('[] :-> ()) -> Ivory s ()
runCheck action = do
  bool <- call check_properties
  ifte bool (return ()) (call_ action)

--------------------------------------------------------------------------------

checkerTask :: ChannelSink (Struct "assignment") -> TaskConstructor
checkerTask src = do
  rx <- withChannelReceiver src "src"
  withContext $ taskLoop $ do
    lastVal <- local (istruct [])
    call_ mkHistory (constRef lastVal)
    handlers $ onChannel rx $ \_ -> runCheck action

--------------------------------------------------------------------------------

checkerTower :: Tower ()
checkerTower = do
  addModule $ package "queueStruct" $ defStruct (Proxy :: Proxy "assignment")
  (src, sink) <- channel
  task "verify_updates" $ checkerTask sink

--------------------------------------------------------------------------------

main :: IO ()
main = do
  let (_, objs) = F.compile checkerTower
  C.runCompiler objs C.initialOpts { C.srcDir = "tower-srcs"
                                   , C.includeDir = "tower-hdrs"
                                   }
  -- graphvizToFile "out.dot" asm
