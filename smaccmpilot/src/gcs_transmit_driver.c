/* This file has been autogenerated by Ivory
 * Compiler version  Version {versionBranch = [0,1,0,0], versionTags = []}
 */
#include "gcs_transmit_driver.h"
void gcs_transmit_send_heartbeat(struct motorsoutput_result* n_var0,
                                 struct userinput_result* n_var1,
                                 struct smavlink_out_channel* n_var2,
                                 struct smavlink_system* n_var3)
{
    struct heartbeat_msg n_local0 = {.custom_mode =0, .mavtype =0, .autopilot =
                                     0, .base_mode =0, .system_status =0,
                                     .mavlink_version =0};
    struct heartbeat_msg* n_ref1 = &n_local0;
    bool n_deref2 = *&n_var0->armed;
    uint8_t n_deref3 = *&n_var1->mode;
    
    *&n_ref1->custom_mode = n_deref3 == 0U ? 0U : n_deref3 ==
        1U ? 2U : n_deref3 == 2U ? 5U : 0U;
    *&n_ref1->mavtype = 2U;
    *&n_ref1->autopilot = 3U;
    if (n_deref2) {
        *&n_ref1->base_mode = 128U;
    } else {
        *&n_ref1->base_mode = 1U;
    }
    *&n_ref1->mavlink_version = 3U;
    smavlink_send_heartbeat(n_ref1, n_var2, n_var3);
    return;
}
void gcs_transmit_send_attitude(struct sensors_result* n_var0,
                                struct smavlink_out_channel* n_var1,
                                struct smavlink_system* n_var2)
{
    struct attitude_msg n_local0 = {.time_boot_ms =0, .roll =0, .pitch =0,
                                    .yaw =0, .rollspeed =0, .pitchspeed =0,
                                    .yawspeed =0};
    struct attitude_msg* n_ref1 = &n_local0;
    uint32_t n_deref2 = *&n_var0->time;
    
    *&n_ref1->time_boot_ms = n_deref2;
    
    float n_deref3 = *&n_var0->roll;
    
    *&n_ref1->roll = n_deref3;
    
    float n_deref4 = *&n_var0->pitch;
    
    *&n_ref1->pitch = n_deref4;
    
    float n_deref5 = *&n_var0->yaw;
    
    *&n_ref1->yaw = n_deref5;
    
    float n_deref6 = *&n_var0->omega_x;
    
    *&n_ref1->rollspeed = n_deref6;
    
    float n_deref7 = *&n_var0->omega_y;
    
    *&n_ref1->rollspeed = n_deref7;
    
    float n_deref8 = *&n_var0->omega_z;
    
    *&n_ref1->rollspeed = n_deref8;
    smavlink_send_attitude(n_ref1, n_var1, n_var2);
    return;
}
void gcs_transmit_send_vfrhud(struct position_result* n_var0,
                              struct motorsoutput_result* n_var1,
                              struct sensors_result* n_var2,
                              struct smavlink_out_channel* n_var3,
                              struct smavlink_system* n_var4)
{
    struct vfr_hud_msg n_local0 = {.airspeed =0, .groundspeed =0, .alt =0,
                                   .climb =0, .heading =0, .throttle =0};
    struct vfr_hud_msg* n_ref1 = &n_local0;
    int16_t n_deref2 = *&n_var0->vx;
    int16_t n_deref3 = *&n_var0->vy;
    int16_t n_deref4 = *&n_var0->vz;
    float n_let5 = (float) (n_deref2 * n_deref2 + n_deref3 * n_deref3 +
                            n_deref4 * n_deref4);
    
    *&n_ref1->groundspeed = sqrtf(n_let5);
    
    int16_t n_deref6 = *&n_var0->vx;
    int16_t n_deref7 = *&n_var0->vy;
    int16_t n_deref8 = *&n_var0->vz;
    float n_let9 = (float) (n_deref6 * n_deref6 + n_deref7 * n_deref7 +
                            n_deref8 * n_deref8);
    
    *&n_ref1->airspeed = sqrtf(n_let9);
    
    int32_t n_deref10 = *&n_var0->gps_alt;
    float n_let11 = (float) n_deref10;
    
    *&n_ref1->alt = n_let11 / 1000.0f;
    
    int16_t n_deref12 = *&n_var0->vz;
    
    *&n_ref1->climb = (float) n_deref12;
    
    float n_deref13 = *&n_var2->yaw;
    float n_let14 = 180.0f / 3.1415927f * n_deref13;
    int16_t n_let15 = (bool) isnan(n_let14) ? 0 : (int16_t) truncf(n_let14);
    
    *&n_ref1->heading = n_let15;
    
    float n_deref16 = *&n_var1->throttle;
    
    *&n_ref1->throttle = (bool) isnan(n_deref16 *
        100.0f) ? 0U : (uint16_t) truncf(n_deref16 * 100.0f);
    smavlink_send_vfr_hud(n_ref1, n_var3, n_var4);
    return;
}
void gcs_transmit_send_servo_output(struct servo_result* n_var0,
                                    struct smavlink_out_channel* n_var1,
                                    struct smavlink_system* n_var2)
{
    struct servo_output_raw_msg n_local0 = {.time_usec =0, .servo1_raw =0,
                                            .servo2_raw =0, .servo3_raw =0,
                                            .servo4_raw =0, .servo5_raw =0,
                                            .servo6_raw =0, .servo7_raw =0,
                                            .servo8_raw =0, .port =0};
    struct servo_output_raw_msg* n_ref1 = &n_local0;
    uint32_t n_deref2 = *&n_var0->time;
    
    *&n_ref1->time_usec = n_deref2;
    
    uint16_t n_deref3 = *&n_var0->servo1;
    
    *&n_ref1->servo1_raw = n_deref3;
    
    uint16_t n_deref4 = *&n_var0->servo2;
    
    *&n_ref1->servo2_raw = n_deref4;
    
    uint16_t n_deref5 = *&n_var0->servo3;
    
    *&n_ref1->servo3_raw = n_deref5;
    
    uint16_t n_deref6 = *&n_var0->servo4;
    
    *&n_ref1->servo4_raw = n_deref6;
    smavlink_send_servo_output_raw(n_ref1, n_var1, n_var2);
}
void gcs_transmit_send_gps_raw_int(struct position_result* n_var0,
                                   struct smavlink_out_channel* n_var1,
                                   struct smavlink_system* n_var2)
{
    struct gps_raw_int_msg n_local0 = {.time_usec =0, .lat =0, .lon =0, .alt =0,
                                       .eph =0, .epv =0, .vel =0, .cog =0,
                                       .fix_type =0, .satellites_visible =0};
    struct gps_raw_int_msg* n_ref1 = &n_local0;
    int32_t n_deref2 = *&n_var0->lat;
    
    *&n_ref1->lat = n_deref2;
    
    int32_t n_deref3 = *&n_var0->lon;
    
    *&n_ref1->lon = n_deref3;
    
    int32_t n_deref4 = *&n_var0->gps_alt;
    
    *&n_ref1->alt = n_deref4;
    *&n_ref1->eph = 10U;
    *&n_ref1->epv = 10U;
    *&n_ref1->vel = 1U;
    *&n_ref1->cog = 359U;
    *&n_ref1->fix_type = 3U;
    *&n_ref1->satellites_visible = 8U;
    smavlink_send_gps_raw_int(n_ref1, n_var1, n_var2);
    return;
}
