/* This file has been autogenerated by Ivory
 * Compiler version  0.1.0.0
 */
#include "param.h"
struct param_info* param_new()
{
    int32_t* n_ref0 = &g_param_count;
    int32_t n_deref1 = *n_ref0;
    
    *n_ref0 = (n_deref1 + 1) % 512;
    
    struct param_info* n_ref2 = g_param_info;
    struct param_info* n_let3 = &n_ref2[n_deref1];
    
    *&n_let3->param_index = n_deref1;
    *&n_let3->param_requested = 0U;
    return n_let3;
}
void param_init_u8(char* n_var0, uint8_t* n_var1)
{
    struct param_info* n_r0 = param_new();
    
    ivory_strlcpy((char*) n_r0->param_name, n_var0, 17U);
    *&n_r0->param_type = 0U;
    *&n_r0->param_ptr_u8 = n_var1;
}
void param_init_u16(char* n_var0, uint16_t* n_var1)
{
    struct param_info* n_r0 = param_new();
    
    ivory_strlcpy((char*) n_r0->param_name, n_var0, 17U);
    *&n_r0->param_type = 1U;
    *&n_r0->param_ptr_u16 = n_var1;
}
void param_init_u32(char* n_var0, uint32_t* n_var1)
{
    struct param_info* n_r0 = param_new();
    
    ivory_strlcpy((char*) n_r0->param_name, n_var0, 17U);
    *&n_r0->param_type = 2U;
    *&n_r0->param_ptr_u32 = n_var1;
}
void param_init_float(char* n_var0, float* n_var1)
{
    struct param_info* n_r0 = param_new();
    
    ivory_strlcpy((char*) n_r0->param_name, n_var0, 17U);
    *&n_r0->param_type = 3U;
    *&n_r0->param_ptr_float = n_var1;
}
struct param_info* param_get_by_name(const char* n_var0)
{
    int32_t* n_ref0 = &g_param_count;
    int32_t n_deref1 = *n_ref0;
    struct param_info* n_ref2 = g_param_info;
    
    for (int32_t n_ix3 = 0; n_ix3 <= (n_deref1 - 1) % 512; n_ix3 = n_ix3 + 1) {
        struct param_info* n_let4 = &n_ref2[n_ix3];
        const char* n_let5 = (const char*) n_let4->param_name;
        uint32_t n_let6 = 17U;
        int32_t n_r7 = strncmp(n_var0, n_let5, n_let6);
        
        if (n_r7 == 0) {
            return n_let4;
        } else { }
    }
    return NULL;
}
struct param_info* param_get_by_index(int32_t n_var0)
{
    int32_t* n_ref0 = &g_param_count;
    int32_t n_deref1 = *n_ref0;
    
    if (n_var0 >= n_deref1) {
        return NULL;
    } else { }
    
    struct param_info* n_ref2 = g_param_info;
    
    return &n_ref2[n_var0];
}
struct param_info* param_get_requested()
{
    int32_t* n_ref0 = &g_param_count;
    int32_t n_deref1 = *n_ref0;
    struct param_info* n_ref2 = g_param_info;
    
    for (int32_t n_ix3 = 0; n_ix3 <= (n_deref1 - 1) % 512; n_ix3 = n_ix3 + 1) {
        struct param_info* n_let4 = &n_ref2[n_ix3];
        uint8_t n_deref5 = *&n_let4->param_requested;
        
        if (n_deref5 != 0U) {
            return n_let4;
        } else { }
    }
    return NULL;
}
float param_get_float_value(struct param_info* n_var0)
{
    uint8_t n_deref0 = *&n_var0->param_type;
    
    if (n_deref0 == 0U) {
        uint8_t* n_deref1 = *&n_var0->param_ptr_u8;
        
        if (NULL != n_deref1) {
            uint8_t n_deref2 = *n_deref1;
            
            return (float) n_deref2;
        } else { }
    } else { }
    if (n_deref0 == 1U) {
        uint16_t* n_deref3 = *&n_var0->param_ptr_u16;
        
        if (NULL != n_deref3) {
            uint16_t n_deref4 = *n_deref3;
            
            return (float) n_deref4;
        } else { }
    } else { }
    if (n_deref0 == 2U) {
        uint32_t* n_deref5 = *&n_var0->param_ptr_u32;
        
        if (NULL != n_deref5) {
            uint32_t n_deref6 = *n_deref5;
            
            return (float) n_deref6;
        } else { }
    } else { }
    if (n_deref0 == 3U) {
        float* n_deref7 = *&n_var0->param_ptr_float;
        
        if (NULL != n_deref7) {
            float n_deref8 = *n_deref7;
            
            return n_deref8;
        } else { }
    } else { }
    return 0.0f;
}
void param_set_float_value(struct param_info* n_var0, float n_var1)
{
    uint8_t n_deref0 = *&n_var0->param_type;
    
    if (n_deref0 == 0U) {
        uint8_t* n_deref1 = *&n_var0->param_ptr_u8;
        
        if (NULL != n_deref1) {
            *n_deref1 = (bool) isnan(n_var1) ? 0U : (uint8_t) truncf(n_var1);
        } else { }
    } else { }
    if (n_deref0 == 1U) {
        uint16_t* n_deref2 = *&n_var0->param_ptr_u16;
        
        if (NULL != n_deref2) {
            *n_deref2 = (bool) isnan(n_var1) ? 0U : (uint16_t) truncf(n_var1);
        } else { }
    } else { }
    if (n_deref0 == 2U) {
        uint32_t* n_deref3 = *&n_var0->param_ptr_u32;
        
        if (NULL != n_deref3) {
            *n_deref3 = (bool) isnan(n_var1) ? 0U : (uint32_t) truncf(n_var1);
        } else { }
    } else { }
    if (n_deref0 == 3U) {
        float* n_deref4 = *&n_var0->param_ptr_float;
        
        if (NULL != n_deref4) {
            *n_deref4 = n_var1;
        } else { }
    } else { }
}
bool param_read_header(int32_t n_var0, struct param_header* n_var1)
{
    uint8_t n_local0[9U] = {};
    uint8_t* n_ref1 = n_local0;
    bool n_r2 = partition_read(n_var0, 0U, (uint8_t*) n_ref1, 9U);
    
    if (!n_r2) {
        return false;
    } else { }
    
    uint32_t n_r3 = smavlink_unpack_uint32_t((const uint8_t*) n_ref1, 0U);
    
    *&n_var1->ph_signature = n_r3;
    
    uint8_t n_r4 = smavlink_unpack_uint8_t((const uint8_t*) n_ref1, 4U);
    
    *&n_var1->ph_seq = n_r4;
    
    uint32_t n_r5 = smavlink_unpack_uint32_t((const uint8_t*) n_ref1, 5U);
    
    *&n_var1->ph_length = n_r5;
    return true;
}
bool param_write_header(int32_t n_var0, const struct param_header* n_var1)
{
    uint8_t n_local0[9U] = {};
    uint8_t* n_ref1 = n_local0;
    uint32_t n_deref2 = *&n_var1->ph_signature;
    
    smavlink_pack_uint32_t((uint8_t*) n_ref1, 0U, n_deref2);
    
    uint8_t n_deref3 = *&n_var1->ph_seq;
    
    smavlink_pack_uint8_t((uint8_t*) n_ref1, 4U, n_deref3);
    
    uint32_t n_deref4 = *&n_var1->ph_length;
    
    smavlink_pack_uint32_t((uint8_t*) n_ref1, 5U, n_deref4);
    
    bool n_r5 = partition_write(n_var0, 0U, (const uint8_t*) n_ref1, 9U);
    
    return n_r5;
}
bool param_is_valid_header(const struct param_header* n_var0)
{
    uint32_t n_deref0 = *&n_var0->ph_signature;
    
    return n_deref0 == 2906522394U;
}
bool param_is_valid_seq(uint8_t n_var0)
{
    return n_var0 != 0U && n_var0 != 255U;
}
uint8_t param_get_next_seq(uint8_t n_var0)
{
    if (n_var0 == 254U) {
        return 1U;
    } else {
        return n_var0 + 1U;
    }
}
int32_t param_get_next_pid(int32_t n_var0)
{
    if (n_var0 == 1) {
        return 2;
    } else {
        return 1;
    }
}
bool param_load()
{
    struct param_header n_local0 = {};
    struct param_header* n_ref1 = &n_local0;
    
    param_read_header(1, n_ref1);
    
    bool n_r2 = param_is_valid_header(n_ref1);
    
    if (n_r2) {
        console_write_string("param: headerA = ");
        console_write_string("{ ");
        console_write_string("ph_signature=");
        
        uint32_t n_deref3 = *&n_ref1->ph_signature;
        
        console_write_u32(n_deref3);
        console_write_string(" ");
        console_write_string("ph_seq=");
        
        uint8_t n_deref4 = *&n_ref1->ph_seq;
        
        console_write_u8(n_deref4);
        console_write_string(" ");
        console_write_string("ph_length=");
        
        uint32_t n_deref5 = *&n_ref1->ph_length;
        
        console_write_u32(n_deref5);
        console_write_string(" }");
        console_write_string("\r\n");
    } else { }
    
    struct param_header n_local6 = {};
    struct param_header* n_ref7 = &n_local6;
    
    param_read_header(2, n_ref7);
    
    bool n_r8 = param_is_valid_header(n_ref7);
    
    if (n_r8) {
        console_write_string("param: headerB = ");
        console_write_string("{ ");
        console_write_string("ph_signature=");
        
        uint32_t n_deref9 = *&n_ref7->ph_signature;
        
        console_write_u32(n_deref9);
        console_write_string(" ");
        console_write_string("ph_seq=");
        
        uint8_t n_deref10 = *&n_ref7->ph_seq;
        
        console_write_u8(n_deref10);
        console_write_string(" ");
        console_write_string("ph_length=");
        
        uint32_t n_deref11 = *&n_ref7->ph_length;
        
        console_write_u32(n_deref11);
        console_write_string(" }");
        console_write_string("\r\n");
    } else { }
    return true;
}
bool param_save_1(int32_t n_var0, uint16_t n_var1, struct param_info* n_var2)
{
    uint8_t n_local0[26U] = {};
    uint8_t* n_ref1 = n_local0;
    uint8_t n_deref2 = *&n_var2->param_type;
    
    if (n_deref2 == 0U) {
        uint8_t* n_deref3 = *&n_var2->param_ptr_u8;
        
        if (NULL != n_deref3) {
            uint8_t n_deref4 = *&n_var2->param_type;
            
            smavlink_pack_uint8_t((uint8_t*) n_ref1, 0U, n_deref4);
            
            char* n_let5 = n_var2->param_name;
            
            for (int32_t n_ix6 = 0; n_ix6 <= 16; n_ix6 = n_ix6 + 1) {
                char n_deref7 = *&n_let5[n_ix6];
                
                smavlink_pack_uint8_t((uint8_t*) n_ref1, 1U + (uint8_t) n_ix6,
                                      n_deref7);
            }
            
            uint8_t n_deref8 = *n_deref3;
            
            smavlink_pack_uint8_t((uint8_t*) n_ref1, 18U, n_deref8);
        } else { }
    } else { }
    if (n_deref2 == 1U) {
        uint16_t* n_deref9 = *&n_var2->param_ptr_u16;
        
        if (NULL != n_deref9) {
            uint8_t n_deref10 = *&n_var2->param_type;
            
            smavlink_pack_uint8_t((uint8_t*) n_ref1, 0U, n_deref10);
            
            char* n_let11 = n_var2->param_name;
            
            for (int32_t n_ix12 = 0; n_ix12 <= 16; n_ix12 = n_ix12 + 1) {
                char n_deref13 = *&n_let11[n_ix12];
                
                smavlink_pack_uint8_t((uint8_t*) n_ref1, 1U + (uint8_t) n_ix12,
                                      n_deref13);
            }
            
            uint16_t n_deref14 = *n_deref9;
            
            smavlink_pack_uint16_t((uint8_t*) n_ref1, 18U, n_deref14);
        } else { }
    } else { }
    if (n_deref2 == 2U) {
        uint32_t* n_deref15 = *&n_var2->param_ptr_u32;
        
        if (NULL != n_deref15) {
            uint8_t n_deref16 = *&n_var2->param_type;
            
            smavlink_pack_uint8_t((uint8_t*) n_ref1, 0U, n_deref16);
            
            char* n_let17 = n_var2->param_name;
            
            for (int32_t n_ix18 = 0; n_ix18 <= 16; n_ix18 = n_ix18 + 1) {
                char n_deref19 = *&n_let17[n_ix18];
                
                smavlink_pack_uint8_t((uint8_t*) n_ref1, 1U + (uint8_t) n_ix18,
                                      n_deref19);
            }
            
            uint32_t n_deref20 = *n_deref15;
            
            smavlink_pack_uint32_t((uint8_t*) n_ref1, 18U, n_deref20);
        } else { }
    } else { }
    if (n_deref2 == 3U) {
        float* n_deref21 = *&n_var2->param_ptr_float;
        
        if (NULL != n_deref21) {
            uint8_t n_deref22 = *&n_var2->param_type;
            
            smavlink_pack_uint8_t((uint8_t*) n_ref1, 0U, n_deref22);
            
            char* n_let23 = n_var2->param_name;
            
            for (int32_t n_ix24 = 0; n_ix24 <= 16; n_ix24 = n_ix24 + 1) {
                char n_deref25 = *&n_let23[n_ix24];
                
                smavlink_pack_uint8_t((uint8_t*) n_ref1, 1U + (uint8_t) n_ix24,
                                      n_deref25);
            }
            
            float n_deref26 = *n_deref21;
            
            smavlink_pack_float((uint8_t*) n_ref1, 18U, n_deref26);
        } else { }
    } else { }
    
    const uint8_t* n_let27 = (const uint8_t*) n_ref1;
    bool n_r28 = partition_write(n_var0, n_var1, n_let27, 26U);
    
    return n_r28;
}
bool param_save()
{
    uint16_t n_local0 = 9U;
    uint16_t* n_ref1 = &n_local0;
    uint32_t n_local2 = 0U;
    uint32_t* n_ref3 = &n_local2;
    int32_t* n_ref4 = &g_param_count;
    int32_t n_deref5 = *n_ref4;
    struct param_info* n_ref6 = g_param_info;
    uint8_t* n_ref7 = &g_param_next_seq;
    int32_t* n_ref8 = &g_param_next_pid;
    int32_t n_deref9 = *n_ref8;
    
    console_write_string("param: writing to partition ");
    
    int32_t n_deref10 = *n_ref8;
    
    console_write_s32((int32_t) n_deref10);
    console_write_string(" seq ");
    
    uint8_t n_deref11 = *n_ref7;
    
    console_write_u8(n_deref11);
    console_write_string("\r\n");
    for (int32_t n_ix12 = 0; n_ix12 <= (n_deref5 - 1) % 512; n_ix12 = n_ix12 +
         1) {
        struct param_info* n_let13 = &n_ref6[n_ix12];
        uint16_t n_deref14 = *n_ref1;
        bool n_r15 = param_save_1(n_deref9, n_deref14, n_let13);
        
        if (n_r15) {
            uint16_t n_deref16 = *n_ref1;
            
            *n_ref1 = n_deref16 + 26U;
            
            uint32_t n_deref17 = *n_ref3;
            
            *n_ref3 = n_deref17 + 26U;
        } else { }
    }
    
    struct param_header n_local18 = {};
    struct param_header* n_ref19 = &n_local18;
    
    *&n_ref19->ph_signature = 2906522394U;
    
    uint8_t n_deref20 = *n_ref7;
    
    *&n_ref19->ph_seq = n_deref20;
    
    uint32_t n_deref21 = *n_ref3;
    
    *&n_ref19->ph_length = n_deref21;
    
    bool n_r22 = param_write_header(n_deref9, n_ref19);
    
    if (!n_r22) {
        return false;
    } else { }
    
    uint8_t n_deref23 = *n_ref7;
    uint8_t n_r24 = param_get_next_seq(n_deref23);
    
    *n_ref7 = n_r24;
    
    int32_t n_deref25 = *n_ref8;
    int32_t n_r26 = param_get_next_pid(n_deref25);
    
    *n_ref8 = n_r26;
    return true;
}
struct param_info g_param_info[512U];
int32_t g_param_count;
int32_t g_param_next_pid = 1 % 3;
uint8_t g_param_next_seq = 1U;
